{"version":3,"file":"readline-stream.js","sources":["../src/readline-stream.ts"],"sourcesContent":["import { Transform, TransformCallback } from \"stream\";\nimport { LineSepOption, getLineSepSplitter } from \"./util/line-sep\";\n\nexport type LineParser<V> = (line: string) => V | Promise<V>;\n\nexport interface ReadLineStreamOptions<V = string> {\n  lineSep?: LineSepOption;\n  encoding?: BufferEncoding;\n  parse?: LineParser<V>;\n}\n\nexport class ReadLineStream<V = string> extends Transform {\n  /** last line which is not finished yet */\n  #unfinishedBuf: string[] = [];\n  #encoding: BufferEncoding | undefined;\n\n  /**\n   * undefined means not initialized;\n   * null means the source stream emits string, so a decoder is not needed\n   * StringDecoder means the source stream emits buffer\n   */\n  #decoder: undefined | null | import(\"string_decoder\").StringDecoder;\n  #lineSep: RegExp | string;\n  #parser: undefined | LineParser<V>;\n\n  constructor(options?: ReadLineStreamOptions<V>) {\n    super({ readableObjectMode: true });\n\n    this.#encoding = options?.encoding;\n    this.#lineSep = getLineSepSplitter(options?.lineSep ?? \"auto\");\n    this.#parser = options?.parse;\n  }\n\n  private async _emitLines(lines: string[]) {\n    const p = this.#parser;\n    if (lines.length > 0) {\n      const values =\n        typeof p === \"function\"\n          ? // process with parser\n            await Promise.all(lines.map(p))\n          : lines;\n\n      for (const v of values) {\n        if (v === null) throw new Error(\"unexpected null when parsing lines\");\n        else this.push(v);\n      }\n    }\n  }\n\n  private async _writeStrAsync(str: string) {\n    const rawLines = str.split(this.#lineSep);\n    const len = rawLines.length;\n\n    if (len === 0) return;\n    if (len === 1) {\n      // str does not contain SEP\n      this.#unfinishedBuf.push(rawLines[0]);\n      return;\n    }\n\n    // [lineEnding, ...lines, unfinishedLine] = rawLines\n    const lines: string[] = [\n      // previous unfinished line is now finished\n      this.#unfinishedBuf.join(\"\") + rawLines[0],\n      ...rawLines.slice(1, -1),\n    ];\n\n    const unfinishedLine = rawLines[len - 1];\n    this.#unfinishedBuf = unfinishedLine.length > 0 ? [unfinishedLine] : [];\n\n    // emit data\n    await this._emitLines(lines);\n  }\n\n  private async _writeChunkAsync(chunk: Buffer | string) {\n    if (this.#decoder === undefined) {\n      // init decoder or set to null\n      if (typeof chunk === \"string\") {\n        this.#decoder = null;\n      } else {\n        const { StringDecoder } = await import(\"string_decoder\");\n        this.#decoder = new StringDecoder(this.#encoding);\n      }\n    }\n\n    let str: string;\n    if (this.#decoder === null) {\n      str = typeof chunk === \"string\" ? chunk : String(chunk);\n    } else {\n      str = this.#decoder.write(chunk as Buffer);\n    }\n\n    if (str.length > 0) await this._writeStrAsync(str);\n  }\n\n  _transform(\n    chunk: Buffer | string,\n    encoding: BufferEncoding,\n    callback: TransformCallback,\n  ): void {\n    this._writeChunkAsync(chunk)\n      .then(() => callback())\n      .catch((err) => callback(err));\n  }\n\n  private async _flushAsync() {\n    const str = this.#decoder?.end();\n    if (str) await this._writeStrAsync(str);\n\n    // process last line before eof\n    const line = this.#unfinishedBuf.join(\"\");\n    this.#unfinishedBuf = [];\n\n    if (line.length > 0) return this._emitLines([line]);\n  }\n\n  _flush(callback: TransformCallback): void {\n    this._flushAsync()\n      .then(() => callback())\n      .catch((err) => callback(err));\n  }\n}\n"],"names":["ReadLineStream","Transform","constructor","options","readableObjectMode","encoding","getLineSepSplitter","lineSep","parse","_emitLines","lines","p","length","values","Promise","all","map","v","Error","push","_writeStrAsync","str","rawLines","split","len","join","slice","unfinishedLine","_writeChunkAsync","chunk","_classPrivateFieldGet","undefined","StringDecoder","String","write","_transform","callback","then","catch","err","_flushAsync","end","line","_flush"],"mappings":"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"}