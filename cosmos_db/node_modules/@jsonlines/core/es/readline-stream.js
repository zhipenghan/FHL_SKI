import 'core-js/modules/es.array.iterator';
import 'core-js/modules/es.promise';
import { _ as _classPrivateFieldSet, g as getLineSepSplitter, a as _classPrivateFieldGet } from './_chunks/line-sep-6e4e0e79.js';
import { Transform } from 'stream';

var _unfinishedBuf = new WeakMap();

var _encoding = new WeakMap();

var _decoder = new WeakMap();

var _lineSep = new WeakMap();

var _parser = new WeakMap();

class ReadLineStream extends Transform {
  constructor(options) {
    var _options$lineSep;

    super({
      readableObjectMode: true
    });
    /** last line which is not finished yet */

    _unfinishedBuf.set(this, {
      writable: true,
      value: void 0
    });

    _encoding.set(this, {
      writable: true,
      value: void 0
    });

    _decoder.set(this, {
      writable: true,
      value: void 0
    });

    _lineSep.set(this, {
      writable: true,
      value: void 0
    });

    _parser.set(this, {
      writable: true,
      value: void 0
    });

    _classPrivateFieldSet(this, _unfinishedBuf, []);

    _classPrivateFieldSet(this, _encoding, options === null || options === void 0 ? void 0 : options.encoding);

    _classPrivateFieldSet(this, _lineSep, getLineSepSplitter((_options$lineSep = options === null || options === void 0 ? void 0 : options.lineSep) !== null && _options$lineSep !== void 0 ? _options$lineSep : "auto"));

    _classPrivateFieldSet(this, _parser, options === null || options === void 0 ? void 0 : options.parse);
  }
  /** last line which is not finished yet */


  async _emitLines(lines) {
    const p = _classPrivateFieldGet(this, _parser);

    if (lines.length > 0) {
      const values = typeof p === "function" ? // process with parser
      await Promise.all(lines.map(p)) : lines;

      for (const v of values) {
        if (v === null) throw new Error("unexpected null when parsing lines");else this.push(v);
      }
    }
  }

  async _writeStrAsync(str) {
    const rawLines = str.split(_classPrivateFieldGet(this, _lineSep));
    const len = rawLines.length;
    if (len === 0) return;

    if (len === 1) {
      // str does not contain SEP
      _classPrivateFieldGet(this, _unfinishedBuf).push(rawLines[0]);

      return;
    } // [lineEnding, ...lines, unfinishedLine] = rawLines


    const lines = [// previous unfinished line is now finished
    _classPrivateFieldGet(this, _unfinishedBuf).join("") + rawLines[0], ...rawLines.slice(1, -1)];
    const unfinishedLine = rawLines[len - 1];

    _classPrivateFieldSet(this, _unfinishedBuf, unfinishedLine.length > 0 ? [unfinishedLine] : []); // emit data


    await this._emitLines(lines);
  }

  async _writeChunkAsync(chunk) {
    if (_classPrivateFieldGet(this, _decoder) === undefined) {
      // init decoder or set to null
      if (typeof chunk === "string") {
        _classPrivateFieldSet(this, _decoder, null);
      } else {
        const {
          StringDecoder
        } = await import('string_decoder');

        _classPrivateFieldSet(this, _decoder, new StringDecoder(_classPrivateFieldGet(this, _encoding)));
      }
    }

    let str;

    if (_classPrivateFieldGet(this, _decoder) === null) {
      str = typeof chunk === "string" ? chunk : String(chunk);
    } else {
      str = _classPrivateFieldGet(this, _decoder).write(chunk);
    }

    if (str.length > 0) await this._writeStrAsync(str);
  }

  _transform(chunk, encoding, callback) {
    this._writeChunkAsync(chunk).then(() => callback()).catch(err => callback(err));
  }

  async _flushAsync() {
    var _classPrivateFieldGet2;

    const str = (_classPrivateFieldGet2 = _classPrivateFieldGet(this, _decoder)) === null || _classPrivateFieldGet2 === void 0 ? void 0 : _classPrivateFieldGet2.end();
    if (str) await this._writeStrAsync(str); // process last line before eof

    const line = _classPrivateFieldGet(this, _unfinishedBuf).join("");

    _classPrivateFieldSet(this, _unfinishedBuf, []);

    if (line.length > 0) return this._emitLines([line]);
  }

  _flush(callback) {
    this._flushAsync().then(() => callback()).catch(err => callback(err));
  }

}

export { ReadLineStream };
//# sourceMappingURL=readline-stream.js.map
