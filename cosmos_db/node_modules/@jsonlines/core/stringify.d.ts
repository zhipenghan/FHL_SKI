/// <reference types="node" />
import { AsyncDuplexBase } from "./util/duplex-base";
import { Transform, TransformCallback } from "stream";
import { JsonLinesGzipOption } from "./parse";
import { LineSepOption } from "./util/line-sep";
export interface JsonLinesStringifyOptions<V> {
    /**
     * specify the encoding to encode string to buffer
     *
     * NOTE that [the standard jsonlines](http://jsonlines.org/)
     * requires `utf8` as file encoding
     *
     * Defaults to `Buffer.from` default encoding,
     * which is `utf8`.
     */
    encoding?: BufferEncoding;
    /**
     * specify a function to stringify values.
     * It accepts a value as parameter,
     * and should return a string or a Promise<string>.
     *
     * Defaults to `JSON.stringify`
     */
    stringify?: (v: V) => string | Promise<string>;
    /**
     * specify whether to gzip the output
     *
     * Omit or use `false` to disable gzip.
     * Use `true` to gzip with default options.
     * Or use an object as params for `require('zlib').createGzip`
     */
    gzip?: JsonLinesGzipOption;
    /**
     * specify the line ending to be used in the output
     *
     * NOTE that [the standard jsonlines](http://jsonlines.org/)
     * requires `\n` as line separator
     *
     * Defaults to `\n`
     */
    lineSep?: LineSepOption;
}
export declare class JsonLinesStringifyStream<V> extends Transform {
    #private;
    readonly encoding: BufferEncoding | undefined;
    readonly lineSep: string;
    constructor(options?: JsonLinesStringifyOptions<V>);
    private _transformAsync;
    _transform(chunk: V, encoding: unknown, callback: TransformCallback): void;
}
export declare class JsonLinesStringifyStreamWithGzip<V = unknown> extends AsyncDuplexBase {
    constructor(options?: JsonLinesStringifyOptions<V>);
}
export declare function stringify<V>(options?: JsonLinesStringifyOptions<V>): JsonLinesStringifyStream<V> | JsonLinesStringifyStreamWithGzip<V>;
