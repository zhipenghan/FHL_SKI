'use strict';

require('core-js/modules/es.array.iterator');
require('core-js/modules/es.promise');
var lineSep = require('./line-sep-69d200dd.js');
var stream = require('stream');

function drain(writable) {
  if (writable.destroyed) {
    return Promise.reject(new Error("premature close"));
  }

  return new Promise((resolve, reject) => {
    const done = () => {
      // eslint-disable-next-line @typescript-eslint/no-use-before-define
      writable.removeListener("close", onClose); // eslint-disable-next-line @typescript-eslint/no-use-before-define

      writable.removeListener("drain", onDrain);
    };

    const onClose = () => {
      done();
      reject(new Error("premature close"));
    };

    const onDrain = () => {
      done();
      resolve();
    };

    writable.on("close", onClose);
    writable.on("drain", onDrain);
  });
}

function resolveAsyncValue(v) {
  return Promise.resolve(typeof v === "function" ? //
  v() : v);
}

async function resolveAsyncDuplexSource(asyncSource) {
  const sc = await resolveAsyncValue(asyncSource);

  if (Array.isArray(sc)) {
    const streams = await Promise.all(sc.map(v => resolveAsyncValue(v)));
    stream.pipeline(streams);
    return {
      writable: streams[0],
      readable: streams[streams.length - 1]
    };
  } else {
    const writable = await resolveAsyncValue(sc.writable);
    const readable = await resolveAsyncValue(sc.readable);
    return {
      writable,
      readable
    };
  }
}

var _asyncSource = new WeakMap();

var _source = new WeakMap();

var _readSetup2 = new WeakMap();

class AsyncDuplexBase extends stream.Duplex {
  constructor(asyncSource, options) {
    super(options);

    _asyncSource.set(this, {
      writable: true,
      value: void 0
    });

    _source.set(this, {
      writable: true,
      value: void 0
    });

    _readSetup2.set(this, {
      writable: true,
      value: void 0
    });

    lineSep._classPrivateFieldSet(this, _readSetup2, false);

    lineSep._classPrivateFieldSet(this, _asyncSource, asyncSource);
  }

  setupSourceOnce() {
    if (lineSep._classPrivateFieldGet(this, _source) === undefined) {
      const asyncSource = lineSep._classPrivateFieldGet(this, _asyncSource);

      if (!asyncSource) throw new Error("invalid state");

      lineSep._classPrivateFieldSet(this, _source, resolveAsyncDuplexSource(asyncSource));
    }

    return lineSep._classPrivateFieldGet(this, _source);
  }

  async __writeAsync__(chunk, encoding, callback) {
    let errIsFromCallback = false;

    try {
      const {
        writable
      } = await this.setupSourceOnce();
      let resolve;
      let reject;
      const p = new Promise((rsv, rjt) => {
        resolve = rsv;
        reject = rjt;
      });

      if (!writable.write(chunk, encoding, err => {
        if (err) reject(err);else resolve();
      })) {
        await drain(writable);
      }

      await p;

      try {
        callback();
      } catch (err) {
        errIsFromCallback = true;
        throw err;
      }
    } catch (err) {
      if (!errIsFromCallback) callback(err);else throw err;
    }
  }

  _write(chunk, encoding, callback) {
    void this.__writeAsync__(chunk, encoding, callback);
  }

  _read(size) {
    if (!lineSep._classPrivateFieldGet(this, _readSetup2)) {
      void this.setupSourceOnce().then(({
        readable
      }) => {
        readable.on("readable", () => {
          let chunk;

          while (null !== (chunk = readable.read(size))) {
            if (!this.push(chunk)) break;
          }
        }).on("end", () => {
          // EOF
          this.push(null);
        });

        lineSep._classPrivateFieldSet(this, _readSetup2, true);
      });
    }
  }

  _final(callback) {
    void this.setupSourceOnce().then(({
      writable
    }) => {
      writable.end(callback);
    });
  }

}

exports.AsyncDuplexBase = AsyncDuplexBase;
//# sourceMappingURL=duplex-base-8f9de019.js.map
