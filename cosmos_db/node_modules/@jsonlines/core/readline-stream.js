'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

require('core-js/modules/es.array.iterator');
require('core-js/modules/es.promise');
var lineSep = require('./_chunks/line-sep-69d200dd.js');
var stream = require('stream');

function _interopNamespace(e) {
    if (e && e.__esModule) { return e; } else {
        var n = Object.create(null);
        if (e) {
            Object.keys(e).forEach(function (k) {
                if (k !== 'default') {
                    var d = Object.getOwnPropertyDescriptor(e, k);
                    Object.defineProperty(n, k, d.get ? d : {
                        enumerable: true,
                        get: function () {
                            return e[k];
                        }
                    });
                }
            });
        }
        n['default'] = e;
        return Object.freeze(n);
    }
}

var _unfinishedBuf = new WeakMap();

var _encoding = new WeakMap();

var _decoder = new WeakMap();

var _lineSep = new WeakMap();

var _parser = new WeakMap();

class ReadLineStream extends stream.Transform {
  constructor(options) {
    var _options$lineSep;

    super({
      readableObjectMode: true
    });
    /** last line which is not finished yet */

    _unfinishedBuf.set(this, {
      writable: true,
      value: void 0
    });

    _encoding.set(this, {
      writable: true,
      value: void 0
    });

    _decoder.set(this, {
      writable: true,
      value: void 0
    });

    _lineSep.set(this, {
      writable: true,
      value: void 0
    });

    _parser.set(this, {
      writable: true,
      value: void 0
    });

    lineSep._classPrivateFieldSet(this, _unfinishedBuf, []);

    lineSep._classPrivateFieldSet(this, _encoding, options === null || options === void 0 ? void 0 : options.encoding);

    lineSep._classPrivateFieldSet(this, _lineSep, lineSep.getLineSepSplitter((_options$lineSep = options === null || options === void 0 ? void 0 : options.lineSep) !== null && _options$lineSep !== void 0 ? _options$lineSep : "auto"));

    lineSep._classPrivateFieldSet(this, _parser, options === null || options === void 0 ? void 0 : options.parse);
  }
  /** last line which is not finished yet */


  async _emitLines(lines) {
    const p = lineSep._classPrivateFieldGet(this, _parser);

    if (lines.length > 0) {
      const values = typeof p === "function" ? // process with parser
      await Promise.all(lines.map(p)) : lines;

      for (const v of values) {
        if (v === null) throw new Error("unexpected null when parsing lines");else this.push(v);
      }
    }
  }

  async _writeStrAsync(str) {
    const rawLines = str.split(lineSep._classPrivateFieldGet(this, _lineSep));
    const len = rawLines.length;
    if (len === 0) return;

    if (len === 1) {
      // str does not contain SEP
      lineSep._classPrivateFieldGet(this, _unfinishedBuf).push(rawLines[0]);

      return;
    } // [lineEnding, ...lines, unfinishedLine] = rawLines


    const lines = [// previous unfinished line is now finished
    lineSep._classPrivateFieldGet(this, _unfinishedBuf).join("") + rawLines[0], ...rawLines.slice(1, -1)];
    const unfinishedLine = rawLines[len - 1];

    lineSep._classPrivateFieldSet(this, _unfinishedBuf, unfinishedLine.length > 0 ? [unfinishedLine] : []); // emit data


    await this._emitLines(lines);
  }

  async _writeChunkAsync(chunk) {
    if (lineSep._classPrivateFieldGet(this, _decoder) === undefined) {
      // init decoder or set to null
      if (typeof chunk === "string") {
        lineSep._classPrivateFieldSet(this, _decoder, null);
      } else {
        const {
          StringDecoder
        } = await Promise.resolve().then(function () { return /*#__PURE__*/_interopNamespace(require('string_decoder')); });

        lineSep._classPrivateFieldSet(this, _decoder, new StringDecoder(lineSep._classPrivateFieldGet(this, _encoding)));
      }
    }

    let str;

    if (lineSep._classPrivateFieldGet(this, _decoder) === null) {
      str = typeof chunk === "string" ? chunk : String(chunk);
    } else {
      str = lineSep._classPrivateFieldGet(this, _decoder).write(chunk);
    }

    if (str.length > 0) await this._writeStrAsync(str);
  }

  _transform(chunk, encoding, callback) {
    this._writeChunkAsync(chunk).then(() => callback()).catch(err => callback(err));
  }

  async _flushAsync() {
    var _classPrivateFieldGet2;

    const str = (_classPrivateFieldGet2 = lineSep._classPrivateFieldGet(this, _decoder)) === null || _classPrivateFieldGet2 === void 0 ? void 0 : _classPrivateFieldGet2.end();
    if (str) await this._writeStrAsync(str); // process last line before eof

    const line = lineSep._classPrivateFieldGet(this, _unfinishedBuf).join("");

    lineSep._classPrivateFieldSet(this, _unfinishedBuf, []);

    if (line.length > 0) return this._emitLines([line]);
  }

  _flush(callback) {
    this._flushAsync().then(() => callback()).catch(err => callback(err));
  }

}

exports.ReadLineStream = ReadLineStream;
//# sourceMappingURL=readline-stream.js.map
